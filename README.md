# TBS-field

# Задание
  1. Нужно реализовать многопользовательскую пошаговую стратегическую игру на два игрока.
  2. Игровое поле генерируется на старте сессии.
  3. Два игрока начинают с некоторым определенным набором юнитов (зеркальный набор) по разные стороны игрового поля.
  4. Каждый игрок в свой ход может совершить два действия: **Перемещение и Атаку**.  
  **Перемещение:** Игрок может приказать одному любому подконтрольному ему юниту переместится в указанную точку в пределах “скорости” юнита. Чем больше “скорость” у юнита - тем большее расстояние юнит может пройти за один ход.  
  **Атака:** Игрок может приказать одному любому подконтрольному ему юниту атаковать юнита противника в пределах “дальности атаки” юнита.
  Игрок может завершить свой ход до того как потратит оба действия. Игрок не может использовать два перемещения или две атаки за один ход.  
  5. На каждый ход игроку выделяется 60 секунд.  
  Для разрешения ситуаций, когда один игрок избегает боя сделать следующий механизм разрешения ничьей:
  - Если на ход номер 15 (или позже) у игроков разное количество юнитов - побеждает игрок у которого осталось больше юнитов
  - Если на ход номер 15 у игроков одинаковое количество юнитов - всем юнитам дается бесконечная “скорость” передвижения.  
# Подробности реализации
## Игровое поле
  1. Игровое поле произвольного размера
     1. Можно задать какие препятствия могут появляться, и зону в пределах которой препятствия могут появляться
     2. В каждом отдельном препятствии можно указать минимальное и максимальное количество препятствий этого типа
     3. Можно задать точки появления юнитов для обоих игроков (Допускается зона с рандомизацией положения юнитов)
     4. Можно задать стартовый состав армий игроков
## Юниты
  1. Два типа юнитов - [медленный но дальнобойный] и [быстрый но с малым радиусом атаки]. Здоровье и урон не обязательны, считаем, что у всех одно очко здоровья и одна единица урона
  2. Левой кнопкой мыши игрок выбирает юнита. Выбранный юнит подсвечивается (Подсветку можно сделать в произвольном виде. Индикатор над юнитом, аутлайн, кружок под юнитом)
  3. Правой кнопкой мыши прогнозируется путь для данного юнита в точку нажатия (Если нажата левая кнопка мыши, то прогнозируемый путь стирается)
  4. Двойным нажатием правой кнопки юнит отправляется в указанную точку
  5. Игрок не может построить путь, который по длине превосходит скорость передвижения юнита и юнит не может начать движение в точку, если длина пути к ней превосходит его скорость
  6. Юнит не может проходить сквозь препятствия
  7. Юнит во время движения не может толкать других юнитов или проходить их сквозь, путь должен строится вокруг других юнитов
  8. У выбранного юнита есть отображение радиуса его атаки. Если построен путь, то радиус атаки отображается из финальной точки пути
  9. Все вражеские юниты внутри радиуса атаки (вокруг юнита когда нет пути и вокруг финальной точки когда путь есть) подсвечиваются
  10. Правой кнопкой мыши по вражескому юниту отдается приказ на атаку. При успешной атаке юнит-цель уничтожается
  11. **Опционально** Нельзя атаковать противников, которые за препятствием
  12. **Опционально** Радиус атаки должен учитывать размер юнитов. Юнит-цель может частично находится в радиусе атаки и быть валидной целью
  13. **Опционально** Не использовать коллайдеры или триггеры для определения целей в радиусе атаки
  14. **Опционально** Сервер не разрешает совершать невалидные действия (примитивная защита от читов)
## Интерфейс
На интерфейсе отображается:  
  1. Текущий таймер хода
  2. Текущий номер хода
  3. Чей сейчас ход
  4. Есть ли возможность совершить передвижение
  5. Есть ли возможность совершить атаку
## Технические требования
  1. Проект разрабатывать на версии Unity 2022 LTS (URP, SRP или HDRP)
  2. Многопользовательское взаимодействие реализовывать на основе Netcode for GameObjects
  3. Лобби, в котором оба игрока должны подтвердить свою готовность не нужно, сессию можно начинать, сразу когда клиент подключится к серверу
  4. **Опционально** На старте сессии сервер не должен передавать состояние всего игрового поля (Препятствия и положение препятствий) клиенту ни в открытом, ни сжатом, ни шифрованном виде. (Считаем, что игровое поле может быть достаточно обширным и содержать достаточно большое количество объектов, что отправка по сети всего поля может вызвать нежелательную нагрузку на сеть и очень долгое время загрузки клиента). Передача по сети данных о юнитах допускается.

# День первый
## Мысли
  1. Проект разделю на модули и подмодули которые будут взаимодействовать между собой, но будут узкоспециализировнными;
  2. Необходим редактор юнитов - пока два типа;
  3. Необходим редактор карт - различный размер + наборы препятствий;
  4. Необходим редактор армий - наборов юнитов для карт;

## Модули и их подмодули
  1. GameLogic - управление игровой логикой, ходами, правилами, действиями;
     1. TurnManager - очередность ходов, таймер;
     2. ActionSystem - настройка и взаимодействие подсистем действий;
     3. VictorySystem - проверка условий победы;
     4. VictoryConditions - условия победы;
     5. RulesConfig - настройки правил игры;
     6. ActionTypes - типы возможных действий;
     7. UnitSelectionSystem - выбор юнитов;
     8. UnitMoveSystem - перемещение юнитов;
     9. UnitAttackSystem - сражение юнитов;
     10. CameraController - обзор и осмотр юнитов;
  2. Networking - сетевое взаимодействие, RPC, обработка входящих команд;
     1. GameNetworkManager - управление сессиями, подключениями;
     2. NetworkCommandHandler - исполнение сетевых команд;
     3. NetworkValidator - валидация сетевых команд;
     4. NetworkSyncHandler - синхронизация состояний игры;
     5. NetworkPlayer - непосредственно сам сетевой игрок;
     6. NetworkPlayerSpawner - создание игроков и их команд;
     7. NetworkSceneManager - работа со сценами игры;
     8. NetworkUnit - непостредственно сам сетевой юнит;
     9. NetworkSystemFactory - создание подсистем;
  3. World - представление игрового мира
     1. WorldGenerator - генерация карты, размещение препятствий;
     2. UnitsManager - создание и размещение юнитов;
     3. Pathfinding - расчет путей;
     4. ObstactleConfig - создание препятствий;
     5. UnitConfig - создание юнитов;
     6. ArmyConfig - создание армий (наборов юнитов);
  4. UI - пользовательский интерфейс
     1. GameHUD - графический игровой интерфейс;
     2. MainMenu - основное меню игры;

# День второй
Создал:
  - Networking
    - GameNetworkManager
    - NetworkPlayer
    - NetworkCommandHandler
    - NetworkSyncHandler
    - NetworkValidator
  - UI
    - GameHUD
    - MainMenu

На текущем этапе получается создавать хост и реализовывать клиентское подключение:
  1. Пользователь запускает игру и видит главное меню (MainMenu).
  2. При нажатии на кнопку "Host" или "Join" вызываются соответствующие методы в GameNetworkManager.
  3. Для хоста:
     1. Создается хост, регистрируются обработчики событий.
     2. После успешного запуска хоста создаются игроки (NetworkPlayer) и синхронизируется состояние игры.
  4. Для клиента:
     1. Клиент подключается к указанному хосту.
     2. После подключения регистрируется локальный игрок и синхронизируется состояние игры.

## Процесс
**Для хоста**
  1. Пользователь нажимает "Host" в MainMenu.
  2. Вызывается GameNetworkManager.StartHostGame().
  3. Регистрируются обработчики событий:
     1. OnHostStarted: вызывается при успешном запуске хоста.
     2. OnHostClientConnected: вызывается при подключении клиента.
  4. Хост запускается (NetworkManager.Singleton.StartHost()).
  5. После запуска хоста:
     1. Создаются NetworkCommandHandler и NetworkSyncHandler.
     2. Создаются игроки (SpawnPlayers): Player1 для хоста, Player2 для клиента.
  6. При подключении клиента:
     1. Вызывается NetworkSyncHandler.SyncGameStateServerRpc для синхронизации состояния.

**Для клиента:**
  1. Пользователь нажимает "Join" в MainMenu, вводит IP (по умолчанию "localhost").
  2. Вызывается GameNetworkManager.JoinGame(ipAddress).
  3. Клиент подключается к хосту (NetworkManager.Singleton.StartClient()).
  4. После подключения:
     1. Вызывается OnClientConnected.
     2. Регистрируется локальный игрок (RegisterLocalPlayer).
     3. Вызывается OnLocalPlayerReady для обновления UI (например, в GameHUD).
  5. Хост синхронизирует состояние игры через NetworkSyncHandler.
## Подмодули

**MainMenu**
  - Управляет UI главного меню.
  - Обрабатывает нажатия кнопок: Host, Join, Quit.
  - Переключает панели для выбора хоста или подключения к игре.
  - Вызывает методы GameNetworkManager для запуска хоста или подключения клиента.

**GameHUD**
  - Отчвечает за отображение HUD во время игры.
  - Управляет визуальными элементами, такими как индикатор игрока и текст текущего хода.
  - Синглтон, сохраняется между сценами.
  - Обновляет визуальные элементы в зависимости от текущего игрока.

**NetworkValidator**
  - (Пока не реализован - заглушка, на будущее.) Предназначен для валидации сетевых действий, например, проверки, является ли текущий ход локального игрока.

**GameNetworkManager**
  - Управляет сетевыми подключениями (хост и клиент).
  - Создает и синхронизирует игроков (NetworkPlayer).
  - Регистрирует обработчики событий подключения.
  - Запускает синхронизацию состояния игры через NetworkSyncHandler.

**NetworkCommandHandler**
  - (Пока не реализован полностью.) Служит для обработки сетевых команд.
  - Хранит ссылки на игроков (NetworkPlayer).

**NetworkSyncHandler**
  - Обеспечивает синхронизацию состояния игры между хостом и клиентами.
  - Использует ServerRpc и ClientRpc для передачи данных.
  - Пока содержит заглушки для синхронизации карты, юнитов и текущего хода.

**NetworkPlayer**
  - Представляет игрока в сети.
  - Содержит информацию о команде игрока (Player.Player1 или Player.Player2).
  - Синхронизирует состояние команды (какая из них) через NetworkVariable.

# День третий

Создал:
  - Networking
    - NetworkSceneManager
    - NetworkPlayerSpawner - вынес в отдельный компонент, перенес часть ранее созданного кода из GameNetworkManager
  - UI
    - GameHUD - доработал
 
  + Создал основную игровую сцену - GameScene.
    + Создал в сцене HUD - UI Canvas

## Процесс

1. В GameNetworkManager доработан OnHostStarted() - дополнительно вызываются SpawnSceneManager() и SpawnPlayerSpawner().
2. Пользователь создает/подключается к игре - вызвав в MainMenu OnHostButtonClick() или OnJoinButtonClick() - вызовется LoadGameScene() в NetworkSceneManager, которая в свою очередь загрузит основную игровую сцену - GameScene, запустит генерацию мира (пока заглушка), создание игроков (spawn) и запросит у TurnManager ход (пока заглушка).
3. В GameScene пользователь увидит:
     1. кнопку с иконкой "BackToMenu" - отключит пользователя от текущей игры, загрузит сцену MainMenu;
     2. изображение "Indicator" в виде щита - которое цыетом будет показывать к какой команде принадлежит игрок - красной или синей;
     3. текст "TurnText" который будет содержать в себе информацию - чей сейчас ход;
     4. текст "TurnCount" уоторый цифрой будет отображать количество уже прошедих ходов.

## Подмодули

**NetworkSceneManager**
 - хранит названия всех сцен игры;
 - позволяет безопасно управлять сценами;

**NetworkPlayerSpawner** 
 - создаёт (spawns) игроков;
 - поределяет к какой команде принадлежит игрок;

# День четвертый

Создал:
  - World
    - ObstacleConfig
    - WorldGenerator
  - UI
    - GameHUD - доработал, добавил индиктор таймера хода и индикаторы "атака", "перемещение".

+ Доработал NetworkSceneManager:
   + при инициализации игрового мира - генерируется мир
   + OnDrawGizmosSelected() показывает точки для спавна будущих юнитов для разных команд

## Процесс
1. Очищает старую карту;
2. Настраивает зоны спавна;
     1. Могут быть расположены по краям (сторонам) или в диагональных углах игрового пространства земли;
3. Создает поверхность - землю;
     1. Создает плоский куб;
     2. Можно выбрать цвет;
     3. Сетевой объект;
4. Генерирует препятствия;
     1. Для каждого типа препятствия создает случайное количество экземпляров;
     2. Ищет позиции которые позволят препятствиям не пересекаться, а также измегать зон появления команд игроков и границ карты;
     3. Препятствия создаются основываясь на заданных им параметров - форма, цыет, масштаб. Поворот всегда случайный.

## Подмодули и SO

**ObstacleConfig**
- ScriptableObject, позволяет создавать и настраивать различные типы препятствий.
- Позволяет настроить: форму (из примитивов), цыет, размер, минимальное и максимальное количество экземпляров препятствия на карте;

**WorldGenerator**
- Отвечает за генерацию игрового мира, включая создание земли, расстановку препятствий и определение зон спавна для игроков. 
- Работает только на сервере в сетевой игре;

# День пятый

Создал/изменил:
  - World
    - WorldGenerator - переделал процесс создания препятствий
  - Networking
    - UnitConfig
    - ArmyConfig
    - NetworkUnit
    - NetworkUnitsManager
  
  + Доработал NetworkSceneManager:
   + после генерации мира запускается процесс создания армий - наборов юнитов

## Процесс
1. Создаю юнит и задаю ему скорость перемещения и радиус атаки и иные параметры
2. Создаю армию - набор юнитов и их количество
3. NetworkSceneManager дает команду на создание армий - SpawnArmies()
     1. Если армия указана в инспекторе - использую ее, если не указана то использую случайную из ранее созданных в Resources
     2. Составляю список всех юнитов и расставляю их, проверяя их позицию (должна быть в зоне спавна игрока, не должна пересекаться с позицией драгого юнита)

## Подмодули и SO

**UnitConfig**
- ScriptableObject, позволяет создавать и настраивать различные типы юнитов;
- Позволяет настроить: название, префаб, тип, радиус перемещения, радиус атаки, размер;

**ArmyConfig**
- ScriptableObject, позволяет создавать и настраивать различные наборы юнитов;
- Позволяет настроить: название, настройку юнита, количество юнитов каждого типа;

**NetworkUnit**
- Представляет юнита в сети.
- Содержит информацию о игроке владельце и параметры юнита;
- Окрашивает юнит в цвет команды игрока.

**NetworkUnitsManager**
- Выбор и использование армии;
- Позиционирование юнитов из армий для каждой команды в пределах ее зоны создания (_spawnZoneSize);
- Армии игроков совпадают;

# День шестой

Создал/изменил:
 - Networking
     - NetworkValidator
 - GameLogic
     - GameRulesConfig;
     - NetworkTurnManager;
     - NetworkActionSystem;
     - NetworkUnitBehaviorController;
     - NetworkVictorySystem;
     - VictoryConditions

## Процесс
1. Игрок инициирует действие через NetworkActionSystem.
2. NetworkValidator проверяет права.
3. NetworkUnitBehaviorController выполняет действие и тратит ход.
4. NetworkTurnManager обновляет состояние и проверяет победу через NetworkVictorySystem.
5. Условия победы (IVictoryCondition) анализируют текущую игровую ситуацию.

## Подмодули и SO

**NetworkValidator**
 - Проверка допустимости действий игрока в сетевой игре (владение, тип активности, текущий ход)
 - Проверка самого игрока (текущий ли он, активный ли он)

**GameRulesConfig**
 - ScriptableObject, позволяет создавать и хранить настройки игры
 - Длительность хода, максимальное число ходов
 - Флаги условий победы

**NetworkTurnManager**
 - Управление очередью ходов, таймером и состоянием игры.
 - Переход хода, проверка условий победы
 
**NetworkActionSystem**
 - Обработка действий игрока

**NetworkUnitBehaviorController**
 - Контроль и выполнение действий юнитов (перемещение, атака)
 - Расчет пути и перемещение (пока заглушка)
 - Проверка дистанции и уничтожение цели

 **NetworkVictorySystem**
 - Управление условиями победы и их проверкой

 **VictoryConditions**
 - Реализация конкретных условий победы
       - победа при уничтожении всех юнитов противника
       - победа по количеству юнитов после 15 ходов

# День седьмой

Создал/изменил:
 - Networking
     - NetworkTurnManager

## Процесс

1. Начальная синхронизация RequestInitialSyncServerRpc (земля, препятствия, юниты, состояние игры)
2. Динамическая синхронизация (регистрация новых объектов, обновлеие данных объектов, уничтожение объектов)
3. Синхронизация состояния игры (ход, таймер, действия, состояние игры). Контроль и оповещение клиентов о результатах игры.

## Подмодули и SO

**NetworkSyncHandler**
 - Централизованная система синхронизации состояния игры между сервером и клиентами в реальном времени
 - Пакетная обработка данных

 # День восьмой

 Создал/изменил:
 - Networking
     - GameNetworkManager
     - NetworkSceneManager
     - GameSystemFactory
 - UI
    - MainMenu
 - GameLogic
    - ActionTypes
    - NetworkActionsSystem
    - NetworkUnitSelectionSystem
    - NetworkUnitMoveSystem
    - NetworkUnitAttackSystem
    - CameraController

## Процесс

1. Переделал процесс запуска хоста:
   1. В первой игровой сцене есть только GameNetworkManager, MainMenu и NetworkSceneManager;
   2. Создал фабрику которая будет создавать необходимых менеджеров и подсистемы;
   3. После нажатия на кнопку "Создать игру" - фабрикой создается NetworkSceneManager и он уже запускает переход в игровую сцену;
   4. В игровой сцене с помощью фабрики создаются все остальные подсистемы.
2. Избавился от NetworkUnitBehaviorController - разделил логику на пять компонентов: ActionTypes, NetworkActionsSystem, NetworkUnitSelectionSystem, NetworkUnitMoveSystem, NetworkUnitAttackSystem.
3. Создал контроллер камеры - работает с Cinemachine и обеспечивает обзор и сопровождение юнитов.

## Подмодули и SO

**GameSystemFactory**
 - Создает префабы содержащие компоненты различных подсистем;

**ActionTypes**
 - Содержит перечисление всех возможных действий юнитов;

**NetworkActionsSystem**
 - Обеспечивает первоначальну настройку NetworkUnitSelectionSystem, NetworkUnitMoveSystem, NetworkUnitAttackSystem;
 - Обеспечивает взаимодействие между своими подсистемами;

**NetworkUnitSelectionSystem**
 - Позволяет выбирать юниты игрока: с помощью нажатия мыши (левая кнопка), а также перебирает по очереди всех юнитов игрока с помощью клавиш клавиатуры W и S.
 - Содержит информацию о текущем выбранном юните;

**NetworkUnitMoveSystem**
 - Для выбранного юнита рассчитывает маршрут (пока заглушка) движения к точке (точка указывается правой кнопкой мыши);
 - Ритует маршрут движения;
 - Перемещает юнит по маршруту в зависимости от его возможной скорости;

**NetworkUnitAttackSystem**
 - Отображает радиус атаки, в том числе и при учете маршрута;
 - Проводит проверку и наносит возможный урон вражескому юниту;

**CameraController**
 - При старте происходит фокусировка на зоне спавна юнитов игрока;
 - Позволяет фокусироваться на выбранном юните;
 - Вращение вокруг выбранного юнито возможно с помощью клавиш клавиатуры A и D;
 - Приближение/отдаление от выбранного юнита возможно с помощью колесика мыши;
 - При каждом выборе юнита происходит плавное перемещение к нему, поворот в его сторону и плавное вращение;

# День девятый

 Создал/изменил:
 - GameLogic
    - NetworkActionsSystem - дополнил для работы с MovementSystem
    - NetworkUnitMoveSystem
    - Pathfinder
 - Networking
    - NetworkCommandHandler - перенес всё запросы для проверки принадлежности Player, NetworkPlayer и Unit.

## Процесс
1. Игрок выбирает юнит (левая кнопка мыши) - появляется индикатор выбора юнита (шарик над его моделью), а также отображается радиус его возможной атаки;
2. Правой кнопкой мыши игрок указывает направление в котород юнит должен переместиться, произойдет расчет маршрута, длина маршрута ограничивается скоростью юнита.  В рассчитанной точке будет показан радиус его возможной атаки юнита.
3. Если произвести двойное нажатие правой кнопки мыши, то юнит переместится в рассчитанную точку.

## Подмодули и SO

**Pathfinder**
 - Перед запуском рассчета, проверяю есть ли возможность ли добраться до цели по прямой;
 - Если прямой путь не получается построить - запускаю А*
       - Выбираю узел с наименьшей общей стоимостью;
       - Если этот узел рядом с целью (<= _cellSize), путь считается найденным;
       - Узел перемещается из openSet (не исследованные) в closedSet (исследованные).
 - Для каждого соседа:
       - Узел пропускается, если уже исследован или непроходим;
       - Рассчитывается новая стоимость перемещения;
       - Если стоимость превышает дальность движения юнита, сосед пропускается;
       - Если новая стоимость лучше или сосед еще не в openSet, обновляются его параметры.
 - H-стоимость - использую манхэттенское расстояние (сумма разностей по X и Z);
 - Когда цель достигнута, путь восстанавливается от конечного узла к начальному через ссылки.
 - Если путь не найден - возвращается ближайший доступный узел к цели из closedSet.
 - Всегда есть проверки - находится ли позиция внутри карты, есть ли препятствия, есьб ли другие юниты.
 - Юниты могут занимать клетки 1х1;
 - Движение возможно по 8 направлениям (включая диагонали);
 - Учитывается ID юнита, чтобы он не блокировал сам себя.